// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common_models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
@_implementationOnly import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// *
/// This enum provides a way for some RPC requests to specify the direction so that the response values are sorted
/// the way you want them to.
/// Note that it specifies the direction only and doesn't say anything about a comparator
/// (e.g. natural order, some RPC-specific order etc).
enum Io_Iohk_Atala_Prism_Protos_SortByDirection: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Nothing provided, each API can define whether to fail or take a default value (commonly ASCENDING).
    case unknown // = 0

    /// Sort the results in ascending order.
    case ascending // = 1

    /// Sort the results in descending order.
    case descending // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .unknown
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .ascending
        case 2: self = .descending
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .ascending: return 1
        case .descending: return 2
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Io_Iohk_Atala_Prism_Protos_SortByDirection: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [Io_Iohk_Atala_Prism_Protos_SortByDirection] = [
            .unknown,
            .ascending,
            .descending,
        ]
    }

#endif // swift(>=4.2)

/// *
/// The supported ledger types. Specifies which chain is used for storing transactions.
enum Io_Iohk_Atala_Prism_Protos_Ledger: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Invalid default value.
    case unknownLedger // = 0

    /// Store transactions in memory instead of blockchain, used only for development.
    case inMemory // = 1

    /// Cardano testnet, used for testing.
    case cardanoTestnet // = 4

    /// Cardano mainnet, used in production.
    case cardanoMainnet // = 5
    case UNRECOGNIZED(Int)

    init() {
        self = .unknownLedger
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownLedger
        case 1: self = .inMemory
        case 4: self = .cardanoTestnet
        case 5: self = .cardanoMainnet
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .unknownLedger: return 0
        case .inMemory: return 1
        case .cardanoTestnet: return 4
        case .cardanoMainnet: return 5
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Io_Iohk_Atala_Prism_Protos_Ledger: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [Io_Iohk_Atala_Prism_Protos_Ledger] = [
            .unknownLedger,
            .inMemory,
            .cardanoTestnet,
            .cardanoMainnet,
        ]
    }

#endif // swift(>=4.2)

/// *
/// The status of an Atala operation.
enum Io_Iohk_Atala_Prism_Protos_OperationStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The operation hasn't been received by the node service yet.
    case unknownOperation // = 0

    /// The transaction containing this operation hasn't been published to the chain yet.
    case pendingSubmission // = 1

    /// The transaction containing this operation has been published to the chain, but hasn't been processed by PRISM yet.
    case awaitConfirmation // = 2

    /// The operation has been successfully applied to the PRISM.
    case confirmedAndApplied // = 3

    /// The operation has been processed by PRISM, but rejected because of some error.
    case confirmedAndRejected // = 4
    case UNRECOGNIZED(Int)

    init() {
        self = .unknownOperation
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownOperation
        case 1: self = .pendingSubmission
        case 2: self = .awaitConfirmation
        case 3: self = .confirmedAndApplied
        case 4: self = .confirmedAndRejected
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .unknownOperation: return 0
        case .pendingSubmission: return 1
        case .awaitConfirmation: return 2
        case .confirmedAndApplied: return 3
        case .confirmedAndRejected: return 4
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Io_Iohk_Atala_Prism_Protos_OperationStatus: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [Io_Iohk_Atala_Prism_Protos_OperationStatus] = [
            .unknownOperation,
            .pendingSubmission,
            .awaitConfirmation,
            .confirmedAndApplied,
            .confirmedAndRejected,
        ]
    }

#endif // swift(>=4.2)

/// *
/// A request that can be used to check service health.
/// All PRISM services expose an RPC that accepts this message as request.
struct Io_Iohk_Atala_Prism_Protos_HealthCheckRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// *
/// A response that represents service health.
/// Status code 0 with empty response represents a healthy and reachable service,
/// while all other status codes represent issues with the service.
struct Io_Iohk_Atala_Prism_Protos_HealthCheckResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// *
/// Represents a date by its parts (day, month, year).
struct Io_Iohk_Atala_Prism_Protos_Date {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A positive value.
    var year: Int32 = 0

    /// A value in the [1, 12] range.
    var month: Int32 = 0

    /// A value in the [1, 31] range (depending on the month, the maximum value might be 28).
    var day: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// *
/// Represents a time interval between two given timestamps.
/// The message represents a closed interval (i.e. both ends are inclusive and mandatory).
struct Io_Iohk_Atala_Prism_Protos_TimeInterval {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// *
    /// The starting timestamp.
    /// start_timestamp must be before or equal to end_timestamp.
    var startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { return _startTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _startTimestamp = newValue }
    }

    /// Returns true if `startTimestamp` has been explicitly set.
    var hasStartTimestamp: Bool { return self._startTimestamp != nil }
    /// Clears the value of `startTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearStartTimestamp() { _startTimestamp = nil }

    /// *
    /// The ending timestamp.
    /// end_timestamp must be after or equal to start_timestamp.
    var endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { return _endTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _endTimestamp = newValue }
    }

    /// Returns true if `endTimestamp` has been explicitly set.
    var hasEndTimestamp: Bool { return self._endTimestamp != nil }
    /// Clears the value of `endTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearEndTimestamp() { _endTimestamp = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp?
    fileprivate var _endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp?
}

/// *
/// Information about a ledger block.
/// See Ledger documentation for details on which ledgers are possible.
struct Io_Iohk_Atala_Prism_Protos_BlockInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Number of the block in the ledger.
    var number: Int32 = 0

    /// Index of the transaction within the block.
    var index: Int32 = 0

    /// Timestamp when the block was created.
    var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _timestamp = newValue }
    }

    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool { return self._timestamp != nil }
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() { _timestamp = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp?
}

/// *
/// Information about a ledger transaction and the block that the transaction is included in.
struct Io_Iohk_Atala_Prism_Protos_TransactionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Transaction ID.
    var transactionID: String = .init()

    /// Ledger the transaction was published to.
    var ledger: Io_Iohk_Atala_Prism_Protos_Ledger = .unknownLedger

    /// Block the transaction was included in.
    var block: Io_Iohk_Atala_Prism_Protos_BlockInfo {
        get { return _block ?? Io_Iohk_Atala_Prism_Protos_BlockInfo() }
        set { _block = newValue }
    }

    /// Returns true if `block` has been explicitly set.
    var hasBlock: Bool { return self._block != nil }
    /// Clears the value of `block`. Subsequent reads from it will return its default value.
    mutating func clearBlock() { _block = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _block: Io_Iohk_Atala_Prism_Protos_BlockInfo?
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "io.iohk.atala.prism.protos"

extension Io_Iohk_Atala_Prism_Protos_SortByDirection: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "SORT_BY_DIRECTION_UNKNOWN"),
        1: .same(proto: "SORT_BY_DIRECTION_ASCENDING"),
        2: .same(proto: "SORT_BY_DIRECTION_DESCENDING"),
    ]
}

extension Io_Iohk_Atala_Prism_Protos_Ledger: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "UNKNOWN_LEDGER"),
        1: .same(proto: "IN_MEMORY"),
        4: .same(proto: "CARDANO_TESTNET"),
        5: .same(proto: "CARDANO_MAINNET"),
    ]
}

extension Io_Iohk_Atala_Prism_Protos_OperationStatus: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "UNKNOWN_OPERATION"),
        1: .same(proto: "PENDING_SUBMISSION"),
        2: .same(proto: "AWAIT_CONFIRMATION"),
        3: .same(proto: "CONFIRMED_AND_APPLIED"),
        4: .same(proto: "CONFIRMED_AND_REJECTED"),
    ]
}

extension Io_Iohk_Atala_Prism_Protos_HealthCheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HealthCheckRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_HealthCheckRequest, rhs: Io_Iohk_Atala_Prism_Protos_HealthCheckRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_HealthCheckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HealthCheckResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_HealthCheckResponse, rhs: Io_Iohk_Atala_Prism_Protos_HealthCheckResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_Date: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Date"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "year"),
        2: .same(proto: "month"),
        3: .same(proto: "day"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt32Field(value: &year)
            case 2: try try decoder.decodeSingularInt32Field(value: &month)
            case 3: try try decoder.decodeSingularInt32Field(value: &day)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if year != 0 {
            try visitor.visitSingularInt32Field(value: year, fieldNumber: 1)
        }
        if month != 0 {
            try visitor.visitSingularInt32Field(value: month, fieldNumber: 2)
        }
        if day != 0 {
            try visitor.visitSingularInt32Field(value: day, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_Date, rhs: Io_Iohk_Atala_Prism_Protos_Date) -> Bool {
        if lhs.year != rhs.year { return false }
        if lhs.month != rhs.month { return false }
        if lhs.day != rhs.day { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_TimeInterval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TimeInterval"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "start_timestamp"),
        2: .standard(proto: "end_timestamp"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_startTimestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_endTimestamp)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _startTimestamp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if let v = _endTimestamp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_TimeInterval, rhs: Io_Iohk_Atala_Prism_Protos_TimeInterval) -> Bool {
        if lhs._startTimestamp != rhs._startTimestamp { return false }
        if lhs._endTimestamp != rhs._endTimestamp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_BlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".BlockInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "number"),
        3: .same(proto: "index"),
        4: .same(proto: "timestamp"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt32Field(value: &number)
            case 3: try try decoder.decodeSingularInt32Field(value: &index)
            case 4: try try decoder.decodeSingularMessageField(value: &_timestamp)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if number != 0 {
            try visitor.visitSingularInt32Field(value: number, fieldNumber: 1)
        }
        if index != 0 {
            try visitor.visitSingularInt32Field(value: index, fieldNumber: 3)
        }
        if let v = _timestamp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_BlockInfo, rhs: Io_Iohk_Atala_Prism_Protos_BlockInfo) -> Bool {
        if lhs.number != rhs.number { return false }
        if lhs.index != rhs.index { return false }
        if lhs._timestamp != rhs._timestamp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "transaction_id"),
        2: .same(proto: "ledger"),
        3: .same(proto: "block"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &transactionID)
            case 2: try try decoder.decodeSingularEnumField(value: &ledger)
            case 3: try try decoder.decodeSingularMessageField(value: &_block)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !transactionID.isEmpty {
            try visitor.visitSingularStringField(value: transactionID, fieldNumber: 1)
        }
        if ledger != .unknownLedger {
            try visitor.visitSingularEnumField(value: ledger, fieldNumber: 2)
        }
        if let v = _block {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_TransactionInfo, rhs: Io_Iohk_Atala_Prism_Protos_TransactionInfo) -> Bool {
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.ledger != rhs.ledger { return false }
        if lhs._block != rhs._block { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
