// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: node_models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
@_implementationOnly import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// Every key has a single purpose:
enum Io_Iohk_Atala_Prism_Protos_KeyUsage: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// UNKNOWN_KEY is an invalid value - Protobuf uses 0 if no value is provided and we want the user to explicitly choose the usage.
    case unknownKey // = 0

    /// This is the most privileged key-type, when any other key is lost, you could use this to recover the others.
    case masterKey // = 1

    /// This key-type is used for issuing credentials only, it should be kept in a safe place
    /// to avoid malicious credentials being issued.
    case issuingKey // = 2

    /// This key-type is used for end-to-end encrypted communication, whoever wants to send a message should
    /// use this key-type to encrypt the content.
    case communicationKey // = 3

    /// This key-type is used to authenticate requests or logging into services.
    case authenticationKey // = 4

    /// This key-type is used for revoking credentials only, it should be kept in a safe place
    /// to avoid malicious credentials being issued.
    case revocationKey // = 5
    case UNRECOGNIZED(Int)

    init() {
        self = .unknownKey
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownKey
        case 1: self = .masterKey
        case 2: self = .issuingKey
        case 3: self = .communicationKey
        case 4: self = .authenticationKey
        case 5: self = .revocationKey
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .unknownKey: return 0
        case .masterKey: return 1
        case .issuingKey: return 2
        case .communicationKey: return 3
        case .authenticationKey: return 4
        case .revocationKey: return 5
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Io_Iohk_Atala_Prism_Protos_KeyUsage: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [Io_Iohk_Atala_Prism_Protos_KeyUsage] = [
            .unknownKey,
            .masterKey,
            .issuingKey,
            .communicationKey,
            .authenticationKey,
            .revocationKey,
        ]
    }

#endif // swift(>=4.2)

/// Includes timestamping details about a blockchain's block.
struct Io_Iohk_Atala_Prism_Protos_TimestampInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The transaction index inside the underlying block.
    var blockSequenceNumber: UInt32 = 0

    /// The operation index inside the AtalaBlock.
    var operationSequenceNumber: UInt32 = 0

    /// The timestamp provided from the underlying blockchain.
    var blockTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { return _blockTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _blockTimestamp = newValue }
    }

    /// Returns true if `blockTimestamp` has been explicitly set.
    var hasBlockTimestamp: Bool { return self._blockTimestamp != nil }
    /// Clears the value of `blockTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearBlockTimestamp() { _blockTimestamp = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _blockTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp?
}

/// *
/// Holds the necessary data to recover an Elliptic Curve (EC)'s public key.
/// @exclude TODO: Consider renaming this to ECPublicKeyData.
struct Io_Iohk_Atala_Prism_Protos_ECKeyData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The curve name, like secp256k1.
    var curve: String = .init()

    /// The x coordinate, represented as bytes.
    var x: Data = .init()

    /// The y coordinate, represented as bytes.
    var y: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// *
/// Holds the compressed representation of data needed to recover Elliptic Curve (EC)'s public key.
/// @exclude TODO: Consider renaming this to CompressedECPublicKeyData.
struct Io_Iohk_Atala_Prism_Protos_CompressedECKeyData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The curve name, like secp256k1.
    var curve: String = .init()

    /// compressed Elliptic Curve (EC) public key data.
    var data: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// *
/// Represents a public key with metadata, necessary for a DID document.
/// @exclude TODO: Consider renaming this to something more specific, like DIDPublicKey.
struct Io_Iohk_Atala_Prism_Protos_PublicKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key identifier within the DID Document.
    var id: String {
        get { return _storage._id }
        set { _uniqueStorage()._id = newValue }
    }

    /// The key's purpose.
    var usage: Io_Iohk_Atala_Prism_Protos_KeyUsage {
        get { return _storage._usage }
        set { _uniqueStorage()._usage = newValue }
    }

    /// The ledger details related to the event that added the key to the DID Document.
    var addedOn: Io_Iohk_Atala_Prism_Protos_LedgerData {
        get { return _storage._addedOn ?? Io_Iohk_Atala_Prism_Protos_LedgerData() }
        set { _uniqueStorage()._addedOn = newValue }
    }

    /// Returns true if `addedOn` has been explicitly set.
    var hasAddedOn: Bool { return _storage._addedOn != nil }
    /// Clears the value of `addedOn`. Subsequent reads from it will return its default value.
    mutating func clearAddedOn() { _uniqueStorage()._addedOn = nil }

    /// The ledger details related to the event that revoked the key to the DID Document.
    var revokedOn: Io_Iohk_Atala_Prism_Protos_LedgerData {
        get { return _storage._revokedOn ?? Io_Iohk_Atala_Prism_Protos_LedgerData() }
        set { _uniqueStorage()._revokedOn = newValue }
    }

    /// Returns true if `revokedOn` has been explicitly set.
    var hasRevokedOn: Bool { return _storage._revokedOn != nil }
    /// Clears the value of `revokedOn`. Subsequent reads from it will return its default value.
    mutating func clearRevokedOn() { _uniqueStorage()._revokedOn = nil }

    /// The key's representation.
    var keyData: OneOf_KeyData? {
        get { return _storage._keyData }
        set { _uniqueStorage()._keyData = newValue }
    }

    /// The Elliptic Curve (EC) key.
    var ecKeyData: Io_Iohk_Atala_Prism_Protos_ECKeyData {
        get {
            if case let .ecKeyData(v)? = _storage._keyData { return v }
            return Io_Iohk_Atala_Prism_Protos_ECKeyData()
        }
        set { _uniqueStorage()._keyData = .ecKeyData(newValue) }
    }

    /// Compressed Elliptic Curve (EC) key.
    var compressedEcKeyData: Io_Iohk_Atala_Prism_Protos_CompressedECKeyData {
        get {
            if case let .compressedEcKeyData(v)? = _storage._keyData { return v }
            return Io_Iohk_Atala_Prism_Protos_CompressedECKeyData()
        }
        set { _uniqueStorage()._keyData = .compressedEcKeyData(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The key's representation.
    enum OneOf_KeyData: Equatable {
        /// The Elliptic Curve (EC) key.
        case ecKeyData(Io_Iohk_Atala_Prism_Protos_ECKeyData)
        /// Compressed Elliptic Curve (EC) key.
        case compressedEcKeyData(Io_Iohk_Atala_Prism_Protos_CompressedECKeyData)

        #if !swift(>=4.1)
            static func == (lhs: Io_Iohk_Atala_Prism_Protos_PublicKey.OneOf_KeyData, rhs: Io_Iohk_Atala_Prism_Protos_PublicKey.OneOf_KeyData) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.ecKeyData, .ecKeyData): return {
                        guard case let .ecKeyData(l) = lhs, case let .ecKeyData(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.compressedEcKeyData, .compressedEcKeyData): return {
                        guard case let .compressedEcKeyData(l) = lhs, case let .compressedEcKeyData(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// The DID Document's data.
struct Io_Iohk_Atala_Prism_Protos_DIDData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The DID suffix, where DID is in form did:prism:[DID suffix]
    var id: String = .init()

    /// The keys that belong to this DID Document.
    var publicKeys: [Io_Iohk_Atala_Prism_Protos_PublicKey] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// The operation to create a public DID.
struct Io_Iohk_Atala_Prism_Protos_CreateDIDOperation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// DIDCreationData with public keys
    var didData: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDCreationData {
        get { return _didData ?? Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDCreationData() }
        set { _didData = newValue }
    }

    /// Returns true if `didData` has been explicitly set.
    var hasDidData: Bool { return self._didData != nil }
    /// Clears the value of `didData`. Subsequent reads from it will return its default value.
    mutating func clearDidData() { _didData = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The data necessary to create a DID.
    struct DIDCreationData {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// The keys that belong to this DID Document.
        var publicKeys: [Io_Iohk_Atala_Prism_Protos_PublicKey] = []

        var services: [Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDService] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    struct DIDService {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var id: String = .init()

        var types: [String] = []

        var serviceEndpoint: String = .init()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    init() {}

    fileprivate var _didData: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDCreationData?
}

/// The necessary data to add a key to a DID.
struct Io_Iohk_Atala_Prism_Protos_AddKeyAction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key to include.
    var key: Io_Iohk_Atala_Prism_Protos_PublicKey {
        get { return _key ?? Io_Iohk_Atala_Prism_Protos_PublicKey() }
        set { _key = newValue }
    }

    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool { return self._key != nil }
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() { _key = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: Io_Iohk_Atala_Prism_Protos_PublicKey?
}

/// The necessary data to remove a key from a DID.
struct Io_Iohk_Atala_Prism_Protos_RemoveKeyAction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the key id to remove
    var keyID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// The potential details that can be updated in a DID.
struct Io_Iohk_Atala_Prism_Protos_UpdateDIDAction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The action to perform.
    var action: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction.OneOf_Action?

    /// Used to add a new key to the DID.
    var addKey: Io_Iohk_Atala_Prism_Protos_AddKeyAction {
        get {
            if case let .addKey(v)? = action { return v }
            return Io_Iohk_Atala_Prism_Protos_AddKeyAction()
        }
        set { action = .addKey(newValue) }
    }

    /// Used to remove a key from the DID.
    var removeKey: Io_Iohk_Atala_Prism_Protos_RemoveKeyAction {
        get {
            if case let .removeKey(v)? = action { return v }
            return Io_Iohk_Atala_Prism_Protos_RemoveKeyAction()
        }
        set { action = .removeKey(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The action to perform.
    enum OneOf_Action: Equatable {
        /// Used to add a new key to the DID.
        case addKey(Io_Iohk_Atala_Prism_Protos_AddKeyAction)
        /// Used to remove a key from the DID.
        case removeKey(Io_Iohk_Atala_Prism_Protos_RemoveKeyAction)

        #if !swift(>=4.1)
            static func == (lhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction.OneOf_Action, rhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction.OneOf_Action) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.addKey, .addKey): return {
                        guard case let .addKey(l) = lhs, case let .addKey(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.removeKey, .removeKey): return {
                        guard case let .removeKey(l) = lhs, case let .removeKey(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    init() {}
}

/// Specifies the necessary data to update a public DID.
struct Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hash of the operation that issued the DID.
    var previousOperationHash: Data = .init()

    /// @exclude TODO: To be redefined after we start using this operation.
    var id: String = .init()

    /// The actual updates to perform on the DID.
    var actions: [Io_Iohk_Atala_Prism_Protos_UpdateDIDAction] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Represents a credential's batch.
///
/// Check the protocol docs to understand it.
struct Io_Iohk_Atala_Prism_Protos_CredentialBatchData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The DID suffix that issues the credential's batch.
    var issuerDid: String = .init()

    /// The Merkle root for the credential's batch.
    var merkleRoot: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Specifies the data to issue a credential batch.
struct Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The actual credential batch data.
    var credentialBatchData: Io_Iohk_Atala_Prism_Protos_CredentialBatchData {
        get { return _credentialBatchData ?? Io_Iohk_Atala_Prism_Protos_CredentialBatchData() }
        set { _credentialBatchData = newValue }
    }

    /// Returns true if `credentialBatchData` has been explicitly set.
    var hasCredentialBatchData: Bool { return self._credentialBatchData != nil }
    /// Clears the value of `credentialBatchData`. Subsequent reads from it will return its default value.
    mutating func clearCredentialBatchData() { _credentialBatchData = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _credentialBatchData: Io_Iohk_Atala_Prism_Protos_CredentialBatchData?
}

/// Specifies the credentials to revoke (the whole batch, or just a subset of it).
struct Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hash of the operation that issued the batch.
    var previousOperationHash: Data = .init()

    /// The corresponding batch ID, as returned in IssueCredentialBatchResponse.
    var credentialBatchID: String = .init()

    /// The hashes of the credentials to revoke. If empty, the full batch is revoked.
    var credentialsToRevoke: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Specifies the protocol version update
struct Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOperation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The DID suffix that proposes the protocol update.
    var proposerDid: String = .init()

    /// Information of the new version
    var version: Io_Iohk_Atala_Prism_Protos_ProtocolVersionInfo {
        get { return _version ?? Io_Iohk_Atala_Prism_Protos_ProtocolVersionInfo() }
        set { _version = newValue }
    }

    /// Returns true if `version` has been explicitly set.
    var hasVersion: Bool { return self._version != nil }
    /// Clears the value of `version`. Subsequent reads from it will return its default value.
    mutating func clearVersion() { _version = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _version: Io_Iohk_Atala_Prism_Protos_ProtocolVersionInfo?
}

struct Io_Iohk_Atala_Prism_Protos_ProtocolVersion {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Represent the major version
    var majorVersion: Int32 = 0

    /// Represent the minor version
    var minorVersion: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Io_Iohk_Atala_Prism_Protos_ProtocolVersionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (optional) name of the version
    var versionName: String = .init()

    /// Cardano block number that tells since which block the update is enforced
    var effectiveSince: Int32 = 0

    /// New major and minor version to be announced,
    /// If major value changes, the node MUST stop issuing and reading operations, and upgrade before `effective_since` because the new protocol version.
    /// If minor value changes, the node can opt to not update. All events _published_ by this node would be also
    /// understood by other nodes with the same major version. However, there may be new events that this node won't _read_
    var protocolVersion: Io_Iohk_Atala_Prism_Protos_ProtocolVersion {
        get { return _protocolVersion ?? Io_Iohk_Atala_Prism_Protos_ProtocolVersion() }
        set { _protocolVersion = newValue }
    }

    /// Returns true if `protocolVersion` has been explicitly set.
    var hasProtocolVersion: Bool { return self._protocolVersion != nil }
    /// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
    mutating func clearProtocolVersion() { _protocolVersion = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _protocolVersion: Io_Iohk_Atala_Prism_Protos_ProtocolVersion?
}

struct Io_Iohk_Atala_Prism_Protos_DeactivateDIDOperation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hash of the operation that issued the DID.
    var previousOperationHash: Data = .init()

    /// DID Suffix of the DID to be deactivated
    var id: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// The possible operations affecting the blockchain.
struct Io_Iohk_Atala_Prism_Protos_AtalaOperation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The actual operation.
    var operation: Io_Iohk_Atala_Prism_Protos_AtalaOperation.OneOf_Operation?

    /// Used to create a public DID.
    var createDid: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation {
        get {
            if case let .createDid(v)? = operation { return v }
            return Io_Iohk_Atala_Prism_Protos_CreateDIDOperation()
        }
        set { operation = .createDid(newValue) }
    }

    /// Used to update an existing public DID.
    var updateDid: Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation {
        get {
            if case let .updateDid(v)? = operation { return v }
            return Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation()
        }
        set { operation = .updateDid(newValue) }
    }

    /// Used to issue a batch of credentials.
    var issueCredentialBatch: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation {
        get {
            if case let .issueCredentialBatch(v)? = operation { return v }
            return Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation()
        }
        set { operation = .issueCredentialBatch(newValue) }
    }

    /// Used to revoke a credential batch.
    var revokeCredentials: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation {
        get {
            if case let .revokeCredentials(v)? = operation { return v }
            return Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation()
        }
        set { operation = .revokeCredentials(newValue) }
    }

    /// Used to announce new protocol update
    var protocolVersionUpdate: Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOperation {
        get {
            if case let .protocolVersionUpdate(v)? = operation { return v }
            return Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOperation()
        }
        set { operation = .protocolVersionUpdate(newValue) }
    }

    /// Used to deactivate DID
    var deactivateDid: Io_Iohk_Atala_Prism_Protos_DeactivateDIDOperation {
        get {
            if case let .deactivateDid(v)? = operation { return v }
            return Io_Iohk_Atala_Prism_Protos_DeactivateDIDOperation()
        }
        set { operation = .deactivateDid(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The actual operation.
    enum OneOf_Operation: Equatable {
        /// Used to create a public DID.
        case createDid(Io_Iohk_Atala_Prism_Protos_CreateDIDOperation)
        /// Used to update an existing public DID.
        case updateDid(Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation)
        /// Used to issue a batch of credentials.
        case issueCredentialBatch(Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation)
        /// Used to revoke a credential batch.
        case revokeCredentials(Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation)
        /// Used to announce new protocol update
        case protocolVersionUpdate(Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOperation)
        /// Used to deactivate DID
        case deactivateDid(Io_Iohk_Atala_Prism_Protos_DeactivateDIDOperation)

        #if !swift(>=4.1)
            static func == (lhs: Io_Iohk_Atala_Prism_Protos_AtalaOperation.OneOf_Operation, rhs: Io_Iohk_Atala_Prism_Protos_AtalaOperation.OneOf_Operation) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.createDid, .createDid): return {
                        guard case let .createDid(l) = lhs, case let .createDid(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.updateDid, .updateDid): return {
                        guard case let .updateDid(l) = lhs, case let .updateDid(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.issueCredentialBatch, .issueCredentialBatch): return {
                        guard case let .issueCredentialBatch(l) = lhs, case let .issueCredentialBatch(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.revokeCredentials, .revokeCredentials): return {
                        guard case let .revokeCredentials(l) = lhs, case let .revokeCredentials(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.protocolVersionUpdate, .protocolVersionUpdate): return {
                        guard case let .protocolVersionUpdate(l) = lhs, case let .protocolVersionUpdate(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.deactivateDid, .deactivateDid): return {
                        guard case let .deactivateDid(l) = lhs, case let .deactivateDid(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    init() {}
}

/// A signed operation, necessary to post anything on the blockchain.
struct Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key ID used to sign the operation, it must belong to the DID that signs the operation.
    var signedWith: String = .init()

    /// The actual signature.
    var signature: Data = .init()

    /// The operation that was signed.
    var operation: Io_Iohk_Atala_Prism_Protos_AtalaOperation {
        get { return _operation ?? Io_Iohk_Atala_Prism_Protos_AtalaOperation() }
        set { _operation = newValue }
    }

    /// Returns true if `operation` has been explicitly set.
    var hasOperation: Bool { return self._operation != nil }
    /// Clears the value of `operation`. Subsequent reads from it will return its default value.
    mutating func clearOperation() { _operation = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _operation: Io_Iohk_Atala_Prism_Protos_AtalaOperation?
}

/// Ledger data associated to a protocol event.
/// Note that the difference with TransactionInfo is that this message contains a full
/// timestamp, and there is no expectation for it to be optional.
struct Io_Iohk_Atala_Prism_Protos_LedgerData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the transaction.
    var transactionID: String = .init()

    /// Ledger the transaction was published to.
    var ledger: Io_Iohk_Atala_Prism_Protos_Ledger = .unknownLedger

    /// The timestamp of the protocol event.
    var timestampInfo: Io_Iohk_Atala_Prism_Protos_TimestampInfo {
        get { return _timestampInfo ?? Io_Iohk_Atala_Prism_Protos_TimestampInfo() }
        set { _timestampInfo = newValue }
    }

    /// Returns true if `timestampInfo` has been explicitly set.
    var hasTimestampInfo: Bool { return self._timestampInfo != nil }
    /// Clears the value of `timestampInfo`. Subsequent reads from it will return its default value.
    mutating func clearTimestampInfo() { _timestampInfo = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timestampInfo: Io_Iohk_Atala_Prism_Protos_TimestampInfo?
}

/// Used to encode the responses of the operations issued in an AtalaBlock.
struct Io_Iohk_Atala_Prism_Protos_OperationOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var result: Io_Iohk_Atala_Prism_Protos_OperationOutput.OneOf_Result?

    /// Represents the response provided by IssueCredentialBatchOperation.
    var batchOutput: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOutput {
        get {
            if case let .batchOutput(v)? = result { return v }
            return Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOutput()
        }
        set { result = .batchOutput(newValue) }
    }

    /// Represents the response provided by CreateDIDOperation.
    var createDidOutput: Io_Iohk_Atala_Prism_Protos_CreateDIDOutput {
        get {
            if case let .createDidOutput(v)? = result { return v }
            return Io_Iohk_Atala_Prism_Protos_CreateDIDOutput()
        }
        set { result = .createDidOutput(newValue) }
    }

    /// Represents the response provided by UpdateDIDOperation.
    var updateDidOutput: Io_Iohk_Atala_Prism_Protos_UpdateDIDOutput {
        get {
            if case let .updateDidOutput(v)? = result { return v }
            return Io_Iohk_Atala_Prism_Protos_UpdateDIDOutput()
        }
        set { result = .updateDidOutput(newValue) }
    }

    /// Represents the response provided by RevokeCredentialOperation.
    var revokeCredentialsOutput: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOutput {
        get {
            if case let .revokeCredentialsOutput(v)? = result { return v }
            return Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOutput()
        }
        set { result = .revokeCredentialsOutput(newValue) }
    }

    /// Represents the response provided by ProtocolVersionUpdateOperation.
    var protocolVersionUpdateOutput: Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOutput {
        get {
            if case let .protocolVersionUpdateOutput(v)? = result { return v }
            return Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOutput()
        }
        set { result = .protocolVersionUpdateOutput(newValue) }
    }

    var deactivateDidOutput: Io_Iohk_Atala_Prism_Protos_DeactivateDIDOutput {
        get {
            if case let .deactivateDidOutput(v)? = result { return v }
            return Io_Iohk_Atala_Prism_Protos_DeactivateDIDOutput()
        }
        set { result = .deactivateDidOutput(newValue) }
    }

    var operationMaybe: Io_Iohk_Atala_Prism_Protos_OperationOutput.OneOf_OperationMaybe?

    /// Operation identifier.
    var operationID: Data {
        get {
            if case let .operationID(v)? = operationMaybe { return v }
            return Data()
        }
        set { operationMaybe = .operationID(newValue) }
    }

    /// Error description if PRISM Node service haven't scheduled the operation.
    var error: String {
        get {
            if case let .error(v)? = operationMaybe { return v }
            return String()
        }
        set { operationMaybe = .error(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Result: Equatable {
        /// Represents the response provided by IssueCredentialBatchOperation.
        case batchOutput(Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOutput)
        /// Represents the response provided by CreateDIDOperation.
        case createDidOutput(Io_Iohk_Atala_Prism_Protos_CreateDIDOutput)
        /// Represents the response provided by UpdateDIDOperation.
        case updateDidOutput(Io_Iohk_Atala_Prism_Protos_UpdateDIDOutput)
        /// Represents the response provided by RevokeCredentialOperation.
        case revokeCredentialsOutput(Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOutput)
        /// Represents the response provided by ProtocolVersionUpdateOperation.
        case protocolVersionUpdateOutput(Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOutput)
        case deactivateDidOutput(Io_Iohk_Atala_Prism_Protos_DeactivateDIDOutput)

        #if !swift(>=4.1)
            static func == (lhs: Io_Iohk_Atala_Prism_Protos_OperationOutput.OneOf_Result, rhs: Io_Iohk_Atala_Prism_Protos_OperationOutput.OneOf_Result) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.batchOutput, .batchOutput): return {
                        guard case let .batchOutput(l) = lhs, case let .batchOutput(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.createDidOutput, .createDidOutput): return {
                        guard case let .createDidOutput(l) = lhs, case let .createDidOutput(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.updateDidOutput, .updateDidOutput): return {
                        guard case let .updateDidOutput(l) = lhs, case let .updateDidOutput(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.revokeCredentialsOutput, .revokeCredentialsOutput): return {
                        guard case let .revokeCredentialsOutput(l) = lhs, case let .revokeCredentialsOutput(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.protocolVersionUpdateOutput, .protocolVersionUpdateOutput): return {
                        guard case let .protocolVersionUpdateOutput(l) = lhs, case let .protocolVersionUpdateOutput(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.deactivateDidOutput, .deactivateDidOutput): return {
                        guard case let .deactivateDidOutput(l) = lhs, case let .deactivateDidOutput(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    enum OneOf_OperationMaybe: Equatable {
        /// Operation identifier.
        case operationID(Data)
        /// Error description if PRISM Node service haven't scheduled the operation.
        case error(String)

        #if !swift(>=4.1)
            static func == (lhs: Io_Iohk_Atala_Prism_Protos_OperationOutput.OneOf_OperationMaybe, rhs: Io_Iohk_Atala_Prism_Protos_OperationOutput.OneOf_OperationMaybe) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.operationID, .operationID): return {
                        guard case let .operationID(l) = lhs, case let .operationID(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.error, .error): return {
                        guard case let .error(l) = lhs, case let .error(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    init() {}
}

struct Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var batchID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Io_Iohk_Atala_Prism_Protos_CreateDIDOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var didSuffix: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Io_Iohk_Atala_Prism_Protos_UpdateDIDOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Io_Iohk_Atala_Prism_Protos_DeactivateDIDOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "io.iohk.atala.prism.protos"

extension Io_Iohk_Atala_Prism_Protos_KeyUsage: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "UNKNOWN_KEY"),
        1: .same(proto: "MASTER_KEY"),
        2: .same(proto: "ISSUING_KEY"),
        3: .same(proto: "COMMUNICATION_KEY"),
        4: .same(proto: "AUTHENTICATION_KEY"),
        5: .same(proto: "REVOCATION_KEY"),
    ]
}

extension Io_Iohk_Atala_Prism_Protos_TimestampInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TimestampInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .standard(proto: "block_sequence_number"),
        3: .standard(proto: "operation_sequence_number"),
        4: .standard(proto: "block_timestamp"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try try decoder.decodeSingularUInt32Field(value: &blockSequenceNumber)
            case 3: try try decoder.decodeSingularUInt32Field(value: &operationSequenceNumber)
            case 4: try try decoder.decodeSingularMessageField(value: &_blockTimestamp)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if blockSequenceNumber != 0 {
            try visitor.visitSingularUInt32Field(value: blockSequenceNumber, fieldNumber: 2)
        }
        if operationSequenceNumber != 0 {
            try visitor.visitSingularUInt32Field(value: operationSequenceNumber, fieldNumber: 3)
        }
        if let v = _blockTimestamp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_TimestampInfo, rhs: Io_Iohk_Atala_Prism_Protos_TimestampInfo) -> Bool {
        if lhs.blockSequenceNumber != rhs.blockSequenceNumber { return false }
        if lhs.operationSequenceNumber != rhs.operationSequenceNumber { return false }
        if lhs._blockTimestamp != rhs._blockTimestamp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_ECKeyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ECKeyData"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "curve"),
        2: .same(proto: "x"),
        3: .same(proto: "y"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &curve)
            case 2: try try decoder.decodeSingularBytesField(value: &x)
            case 3: try try decoder.decodeSingularBytesField(value: &y)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !curve.isEmpty {
            try visitor.visitSingularStringField(value: curve, fieldNumber: 1)
        }
        if !x.isEmpty {
            try visitor.visitSingularBytesField(value: x, fieldNumber: 2)
        }
        if !y.isEmpty {
            try visitor.visitSingularBytesField(value: y, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_ECKeyData, rhs: Io_Iohk_Atala_Prism_Protos_ECKeyData) -> Bool {
        if lhs.curve != rhs.curve { return false }
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_CompressedECKeyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CompressedECKeyData"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "curve"),
        2: .same(proto: "data"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &curve)
            case 2: try try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !curve.isEmpty {
            try visitor.visitSingularStringField(value: curve, fieldNumber: 1)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_CompressedECKeyData, rhs: Io_Iohk_Atala_Prism_Protos_CompressedECKeyData) -> Bool {
        if lhs.curve != rhs.curve { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PublicKey"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "usage"),
        5: .standard(proto: "added_on"),
        6: .standard(proto: "revoked_on"),
        8: .standard(proto: "ec_key_data"),
        9: .standard(proto: "compressed_ec_key_data"),
    ]

    fileprivate class _StorageClass {
        var _id: String = .init()
        var _usage: Io_Iohk_Atala_Prism_Protos_KeyUsage = .unknownKey
        var _addedOn: Io_Iohk_Atala_Prism_Protos_LedgerData?
        var _revokedOn: Io_Iohk_Atala_Prism_Protos_LedgerData?
        var _keyData: Io_Iohk_Atala_Prism_Protos_PublicKey.OneOf_KeyData?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _id = source._id
            _usage = source._usage
            _addedOn = source._addedOn
            _revokedOn = source._revokedOn
            _keyData = source._keyData
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularStringField(value: &_storage._id)
                case 2: try try decoder.decodeSingularEnumField(value: &_storage._usage)
                case 5: try try decoder.decodeSingularMessageField(value: &_storage._addedOn)
                case 6: try try decoder.decodeSingularMessageField(value: &_storage._revokedOn)
                case 8: try {
                        var v: Io_Iohk_Atala_Prism_Protos_ECKeyData?
                        var hadOneofValue = false
                        if let current = _storage._keyData {
                            hadOneofValue = true
                            if case let .ecKeyData(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v = v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._keyData = .ecKeyData(v)
                        }
                    }()
                case 9: try {
                        var v: Io_Iohk_Atala_Prism_Protos_CompressedECKeyData?
                        var hadOneofValue = false
                        if let current = _storage._keyData {
                            hadOneofValue = true
                            if case let .compressedEcKeyData(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v = v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._keyData = .compressedEcKeyData(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._id.isEmpty {
                try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
            }
            if _storage._usage != .unknownKey {
                try visitor.visitSingularEnumField(value: _storage._usage, fieldNumber: 2)
            }
            if let v = _storage._addedOn {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }
            if let v = _storage._revokedOn {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch _storage._keyData {
            case .ecKeyData?: try {
                    guard case let .ecKeyData(v)? = _storage._keyData else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
                }()
            case .compressedEcKeyData?: try {
                    guard case let .compressedEcKeyData(v)? = _storage._keyData else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_PublicKey, rhs: Io_Iohk_Atala_Prism_Protos_PublicKey) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._id != rhs_storage._id { return false }
                if _storage._usage != rhs_storage._usage { return false }
                if _storage._addedOn != rhs_storage._addedOn { return false }
                if _storage._revokedOn != rhs_storage._revokedOn { return false }
                if _storage._keyData != rhs_storage._keyData { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_DIDData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DIDData"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "public_keys"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeRepeatedMessageField(value: &publicKeys)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !publicKeys.isEmpty {
            try visitor.visitRepeatedMessageField(value: publicKeys, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_DIDData, rhs: Io_Iohk_Atala_Prism_Protos_DIDData) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.publicKeys != rhs.publicKeys { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_CreateDIDOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateDIDOperation"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "did_data"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_didData)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _didData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation, rhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation) -> Bool {
        if lhs._didData != rhs._didData { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDCreationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.protoMessageName + ".DIDCreationData"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .standard(proto: "public_keys"),
        3: .same(proto: "services"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try try decoder.decodeRepeatedMessageField(value: &publicKeys)
            case 3: try try decoder.decodeRepeatedMessageField(value: &services)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !publicKeys.isEmpty {
            try visitor.visitRepeatedMessageField(value: publicKeys, fieldNumber: 2)
        }
        if !services.isEmpty {
            try visitor.visitRepeatedMessageField(value: services, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDCreationData, rhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDCreationData) -> Bool {
        if lhs.publicKeys != rhs.publicKeys { return false }
        if lhs.services != rhs.services { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.protoMessageName + ".DIDService"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "types"),
        3: .same(proto: "serviceEndpoint"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeRepeatedStringField(value: &types)
            case 3: try try decoder.decodeSingularStringField(value: &serviceEndpoint)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !types.isEmpty {
            try visitor.visitRepeatedStringField(value: types, fieldNumber: 2)
        }
        if !serviceEndpoint.isEmpty {
            try visitor.visitSingularStringField(value: serviceEndpoint, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDService, rhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation.DIDService) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.types != rhs.types { return false }
        if lhs.serviceEndpoint != rhs.serviceEndpoint { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_AddKeyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AddKeyAction"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_key)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _key {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_AddKeyAction, rhs: Io_Iohk_Atala_Prism_Protos_AddKeyAction) -> Bool {
        if lhs._key != rhs._key { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_RemoveKeyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemoveKeyAction"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "keyId"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &keyID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !keyID.isEmpty {
            try visitor.visitSingularStringField(value: keyID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_RemoveKeyAction, rhs: Io_Iohk_Atala_Prism_Protos_RemoveKeyAction) -> Bool {
        if lhs.keyID != rhs.keyID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_UpdateDIDAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateDIDAction"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "add_key"),
        2: .standard(proto: "remove_key"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Io_Iohk_Atala_Prism_Protos_AddKeyAction?
                    var hadOneofValue = false
                    if let current = self.action {
                        hadOneofValue = true
                        if case let .addKey(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.action = .addKey(v)
                    }
                }()
            case 2: try {
                    var v: Io_Iohk_Atala_Prism_Protos_RemoveKeyAction?
                    var hadOneofValue = false
                    if let current = self.action {
                        hadOneofValue = true
                        if case let .removeKey(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.action = .removeKey(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch action {
        case .addKey?: try {
                guard case let .addKey(v)? = self.action else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .removeKey?: try {
                guard case let .removeKey(v)? = self.action else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction, rhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction) -> Bool {
        if lhs.action != rhs.action { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateDIDOperation"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "previous_operation_hash"),
        2: .same(proto: "id"),
        3: .same(proto: "actions"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularBytesField(value: &previousOperationHash)
            case 2: try try decoder.decodeSingularStringField(value: &id)
            case 3: try try decoder.decodeRepeatedMessageField(value: &actions)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !previousOperationHash.isEmpty {
            try visitor.visitSingularBytesField(value: previousOperationHash, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        if !actions.isEmpty {
            try visitor.visitRepeatedMessageField(value: actions, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation, rhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation) -> Bool {
        if lhs.previousOperationHash != rhs.previousOperationHash { return false }
        if lhs.id != rhs.id { return false }
        if lhs.actions != rhs.actions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_CredentialBatchData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CredentialBatchData"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "issuer_did"),
        2: .standard(proto: "merkle_root"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &issuerDid)
            case 2: try try decoder.decodeSingularBytesField(value: &merkleRoot)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !issuerDid.isEmpty {
            try visitor.visitSingularStringField(value: issuerDid, fieldNumber: 1)
        }
        if !merkleRoot.isEmpty {
            try visitor.visitSingularBytesField(value: merkleRoot, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_CredentialBatchData, rhs: Io_Iohk_Atala_Prism_Protos_CredentialBatchData) -> Bool {
        if lhs.issuerDid != rhs.issuerDid { return false }
        if lhs.merkleRoot != rhs.merkleRoot { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IssueCredentialBatchOperation"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "credential_batch_data"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_credentialBatchData)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _credentialBatchData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation, rhs: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation) -> Bool {
        if lhs._credentialBatchData != rhs._credentialBatchData { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RevokeCredentialsOperation"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "previous_operation_hash"),
        2: .standard(proto: "credential_batch_id"),
        3: .standard(proto: "credentials_to_revoke"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularBytesField(value: &previousOperationHash)
            case 2: try try decoder.decodeSingularStringField(value: &credentialBatchID)
            case 3: try try decoder.decodeRepeatedBytesField(value: &credentialsToRevoke)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !previousOperationHash.isEmpty {
            try visitor.visitSingularBytesField(value: previousOperationHash, fieldNumber: 1)
        }
        if !credentialBatchID.isEmpty {
            try visitor.visitSingularStringField(value: credentialBatchID, fieldNumber: 2)
        }
        if !credentialsToRevoke.isEmpty {
            try visitor.visitRepeatedBytesField(value: credentialsToRevoke, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation, rhs: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation) -> Bool {
        if lhs.previousOperationHash != rhs.previousOperationHash { return false }
        if lhs.credentialBatchID != rhs.credentialBatchID { return false }
        if lhs.credentialsToRevoke != rhs.credentialsToRevoke { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ProtocolVersionUpdateOperation"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "proposer_did"),
        2: .same(proto: "version"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &proposerDid)
            case 2: try try decoder.decodeSingularMessageField(value: &_version)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !proposerDid.isEmpty {
            try visitor.visitSingularStringField(value: proposerDid, fieldNumber: 1)
        }
        if let v = _version {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOperation, rhs: Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOperation) -> Bool {
        if lhs.proposerDid != rhs.proposerDid { return false }
        if lhs._version != rhs._version { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_ProtocolVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ProtocolVersion"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "major_version"),
        2: .standard(proto: "minor_version"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt32Field(value: &majorVersion)
            case 2: try try decoder.decodeSingularInt32Field(value: &minorVersion)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if majorVersion != 0 {
            try visitor.visitSingularInt32Field(value: majorVersion, fieldNumber: 1)
        }
        if minorVersion != 0 {
            try visitor.visitSingularInt32Field(value: minorVersion, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_ProtocolVersion, rhs: Io_Iohk_Atala_Prism_Protos_ProtocolVersion) -> Bool {
        if lhs.majorVersion != rhs.majorVersion { return false }
        if lhs.minorVersion != rhs.minorVersion { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_ProtocolVersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ProtocolVersionInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "version_name"),
        4: .standard(proto: "effective_since"),
        5: .standard(proto: "protocol_version"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &versionName)
            case 4: try try decoder.decodeSingularInt32Field(value: &effectiveSince)
            case 5: try try decoder.decodeSingularMessageField(value: &_protocolVersion)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !versionName.isEmpty {
            try visitor.visitSingularStringField(value: versionName, fieldNumber: 1)
        }
        if effectiveSince != 0 {
            try visitor.visitSingularInt32Field(value: effectiveSince, fieldNumber: 4)
        }
        if let v = _protocolVersion {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_ProtocolVersionInfo, rhs: Io_Iohk_Atala_Prism_Protos_ProtocolVersionInfo) -> Bool {
        if lhs.versionName != rhs.versionName { return false }
        if lhs.effectiveSince != rhs.effectiveSince { return false }
        if lhs._protocolVersion != rhs._protocolVersion { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_DeactivateDIDOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeactivateDIDOperation"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "previous_operation_hash"),
        2: .same(proto: "id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularBytesField(value: &previousOperationHash)
            case 2: try try decoder.decodeSingularStringField(value: &id)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !previousOperationHash.isEmpty {
            try visitor.visitSingularBytesField(value: previousOperationHash, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_DeactivateDIDOperation, rhs: Io_Iohk_Atala_Prism_Protos_DeactivateDIDOperation) -> Bool {
        if lhs.previousOperationHash != rhs.previousOperationHash { return false }
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_AtalaOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AtalaOperation"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "create_did"),
        2: .standard(proto: "update_did"),
        3: .standard(proto: "issue_credential_batch"),
        4: .standard(proto: "revoke_credentials"),
        5: .standard(proto: "protocol_version_update"),
        6: .standard(proto: "deactivate_did"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation?
                    var hadOneofValue = false
                    if let current = self.operation {
                        hadOneofValue = true
                        if case let .createDid(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.operation = .createDid(v)
                    }
                }()
            case 2: try {
                    var v: Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation?
                    var hadOneofValue = false
                    if let current = self.operation {
                        hadOneofValue = true
                        if case let .updateDid(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.operation = .updateDid(v)
                    }
                }()
            case 3: try {
                    var v: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation?
                    var hadOneofValue = false
                    if let current = self.operation {
                        hadOneofValue = true
                        if case let .issueCredentialBatch(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.operation = .issueCredentialBatch(v)
                    }
                }()
            case 4: try {
                    var v: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation?
                    var hadOneofValue = false
                    if let current = self.operation {
                        hadOneofValue = true
                        if case let .revokeCredentials(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.operation = .revokeCredentials(v)
                    }
                }()
            case 5: try {
                    var v: Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOperation?
                    var hadOneofValue = false
                    if let current = self.operation {
                        hadOneofValue = true
                        if case let .protocolVersionUpdate(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.operation = .protocolVersionUpdate(v)
                    }
                }()
            case 6: try {
                    var v: Io_Iohk_Atala_Prism_Protos_DeactivateDIDOperation?
                    var hadOneofValue = false
                    if let current = self.operation {
                        hadOneofValue = true
                        if case let .deactivateDid(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.operation = .deactivateDid(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch operation {
        case .createDid?: try {
                guard case let .createDid(v)? = self.operation else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .updateDid?: try {
                guard case let .updateDid(v)? = self.operation else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .issueCredentialBatch?: try {
                guard case let .issueCredentialBatch(v)? = self.operation else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .revokeCredentials?: try {
                guard case let .revokeCredentials(v)? = self.operation else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .protocolVersionUpdate?: try {
                guard case let .protocolVersionUpdate(v)? = self.operation else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case .deactivateDid?: try {
                guard case let .deactivateDid(v)? = self.operation else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_AtalaOperation, rhs: Io_Iohk_Atala_Prism_Protos_AtalaOperation) -> Bool {
        if lhs.operation != rhs.operation { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SignedAtalaOperation"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "signed_with"),
        2: .same(proto: "signature"),
        3: .same(proto: "operation"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &signedWith)
            case 2: try try decoder.decodeSingularBytesField(value: &signature)
            case 3: try try decoder.decodeSingularMessageField(value: &_operation)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !signedWith.isEmpty {
            try visitor.visitSingularStringField(value: signedWith, fieldNumber: 1)
        }
        if !signature.isEmpty {
            try visitor.visitSingularBytesField(value: signature, fieldNumber: 2)
        }
        if let v = _operation {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation, rhs: Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation) -> Bool {
        if lhs.signedWith != rhs.signedWith { return false }
        if lhs.signature != rhs.signature { return false }
        if lhs._operation != rhs._operation { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_LedgerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LedgerData"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "transaction_id"),
        2: .same(proto: "ledger"),
        3: .standard(proto: "timestamp_info"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &transactionID)
            case 2: try try decoder.decodeSingularEnumField(value: &ledger)
            case 3: try try decoder.decodeSingularMessageField(value: &_timestampInfo)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !transactionID.isEmpty {
            try visitor.visitSingularStringField(value: transactionID, fieldNumber: 1)
        }
        if ledger != .unknownLedger {
            try visitor.visitSingularEnumField(value: ledger, fieldNumber: 2)
        }
        if let v = _timestampInfo {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_LedgerData, rhs: Io_Iohk_Atala_Prism_Protos_LedgerData) -> Bool {
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.ledger != rhs.ledger { return false }
        if lhs._timestampInfo != rhs._timestampInfo { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_OperationOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".OperationOutput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "batch_output"),
        2: .standard(proto: "create_did_output"),
        3: .standard(proto: "update_did_output"),
        4: .standard(proto: "revoke_credentials_output"),
        7: .standard(proto: "protocol_version_update_output"),
        8: .standard(proto: "deactivate_did_output"),
        5: .standard(proto: "operation_id"),
        6: .same(proto: "error"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOutput?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .batchOutput(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .batchOutput(v)
                    }
                }()
            case 2: try {
                    var v: Io_Iohk_Atala_Prism_Protos_CreateDIDOutput?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .createDidOutput(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .createDidOutput(v)
                    }
                }()
            case 3: try {
                    var v: Io_Iohk_Atala_Prism_Protos_UpdateDIDOutput?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .updateDidOutput(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .updateDidOutput(v)
                    }
                }()
            case 4: try {
                    var v: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOutput?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .revokeCredentialsOutput(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .revokeCredentialsOutput(v)
                    }
                }()
            case 5: try {
                    var v: Data?
                    try decoder.decodeSingularBytesField(value: &v)
                    if let v = v {
                        if self.operationMaybe != nil { try decoder.handleConflictingOneOf() }
                        self.operationMaybe = .operationID(v)
                    }
                }()
            case 6: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.operationMaybe != nil { try decoder.handleConflictingOneOf() }
                        self.operationMaybe = .error(v)
                    }
                }()
            case 7: try {
                    var v: Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOutput?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .protocolVersionUpdateOutput(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .protocolVersionUpdateOutput(v)
                    }
                }()
            case 8: try {
                    var v: Io_Iohk_Atala_Prism_Protos_DeactivateDIDOutput?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .deactivateDidOutput(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .deactivateDidOutput(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch result {
        case .batchOutput?: try {
                guard case let .batchOutput(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .createDidOutput?: try {
                guard case let .createDidOutput(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .updateDidOutput?: try {
                guard case let .updateDidOutput(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .revokeCredentialsOutput?: try {
                guard case let .revokeCredentialsOutput(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        default: break
        }
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch operationMaybe {
        case .operationID?: try {
                guard case let .operationID(v)? = self.operationMaybe else { preconditionFailure() }
                try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
            }()
        case .error?: try {
                guard case let .error(v)? = self.operationMaybe else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 6)
            }()
        case nil: break
        }
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch result {
        case .protocolVersionUpdateOutput?: try {
                guard case let .protocolVersionUpdateOutput(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .deactivateDidOutput?: try {
                guard case let .deactivateDidOutput(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        default: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_OperationOutput, rhs: Io_Iohk_Atala_Prism_Protos_OperationOutput) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.operationMaybe != rhs.operationMaybe { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IssueCredentialBatchOutput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "batch_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &batchID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !batchID.isEmpty {
            try visitor.visitSingularStringField(value: batchID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOutput, rhs: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOutput) -> Bool {
        if lhs.batchID != rhs.batchID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_CreateDIDOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateDIDOutput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "did_suffix"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &didSuffix)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !didSuffix.isEmpty {
            try visitor.visitSingularStringField(value: didSuffix, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOutput, rhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOutput) -> Bool {
        if lhs.didSuffix != rhs.didSuffix { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_UpdateDIDOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateDIDOutput"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDOutput, rhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDOutput) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RevokeCredentialsOutput"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOutput, rhs: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOutput) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ProtocolVersionUpdateOutput"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOutput, rhs: Io_Iohk_Atala_Prism_Protos_ProtocolVersionUpdateOutput) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Io_Iohk_Atala_Prism_Protos_DeactivateDIDOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeactivateDIDOutput"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Io_Iohk_Atala_Prism_Protos_DeactivateDIDOutput, rhs: Io_Iohk_Atala_Prism_Protos_DeactivateDIDOutput) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
