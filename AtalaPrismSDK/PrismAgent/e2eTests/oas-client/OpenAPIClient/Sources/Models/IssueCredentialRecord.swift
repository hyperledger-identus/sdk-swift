//
// IssueCredentialRecord.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct IssueCredentialRecord: Codable {
    public enum Role: String, Codable, CaseIterable {
        case issuer = "Issuer"
        case holder = "Holder"
    }
    public enum ProtocolState: String, Codable, CaseIterable {
        case offerPending = "OfferPending"
        case offerSent = "OfferSent"
        case offerReceived = "OfferReceived"
        case requestPending = "RequestPending"
        case requestGenerated = "RequestGenerated"
        case requestSent = "RequestSent"
        case requestReceived = "RequestReceived"
        case credentialPending = "CredentialPending"
        case credentialGenerated = "CredentialGenerated"
        case credentialSent = "CredentialSent"
        case credentialReceived = "CredentialReceived"
        case problemReportPending = "ProblemReportPending"
        case problemReportSent = "ProblemReportSent"
        case problemReportReceived = "ProblemReportReceived"
    }
    /// The unique identifier of the issue credential record.
    public var recordId: String
    /// The unique identifier of the thread this credential record belongs to. The value will identical on both sides of the issue flow (issuer and holder)
    public var thid: String
    /// The identifier (e.g DID) of the subject to which the verifiable credential will be issued.
    public var subjectId: String?
    /// The validity period in seconds of the verifiable credential that will be issued.
    public var validityPeriod: Double?
    /// The claims that will be associated with the issued verifiable credential.
    public var claims: Any?
    /// Specifies whether or not the credential should be automatically generated and issued when receiving the `CredentialRequest` from the holder. If set to `false`, a manual approval by the issuer via API call will be required for the VC to be issued.
    public var automaticIssuance: Bool?
    /// The date and time when the issue credential record was created.
    public var createdAt: Date
    /// The date and time when the issue credential record was last updated.
    public var updatedAt: Date?
    /// The role played by the Prism agent in the credential issuance flow.
    public var role: Role
    /// The current state of the issue credential protocol execution.
    public var protocolState: ProtocolState
    /// The base64-encoded JWT verifiable credential that has been sent by the issuer.
    public var jwtCredential: String?
    /// Issuer DID of the verifiable credential object.
    public var issuingDID: String?

    public init(recordId: String, thid: String, subjectId: String? = nil, validityPeriod: Double? = nil, claims: Any?, automaticIssuance: Bool? = nil, createdAt: Date, updatedAt: Date? = nil, role: Role, protocolState: ProtocolState, jwtCredential: String? = nil, issuingDID: String? = nil) {
        self.recordId = recordId
        self.thid = thid
        self.subjectId = subjectId
        self.validityPeriod = validityPeriod
        self.claims = claims
        self.automaticIssuance = automaticIssuance
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.role = role
        self.protocolState = protocolState
        self.jwtCredential = jwtCredential
        self.issuingDID = issuingDID
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case recordId
        case thid
        case subjectId
        case validityPeriod
        case claims
        case automaticIssuance
        case createdAt
        case updatedAt
        case role
        case protocolState
        case jwtCredential
        case issuingDID
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        recordId = try container.decode(String.self, forKey: .recordId)
        thid = try container.decode(String.self, forKey: .thid)
        subjectId = try container.decodeIfPresent(String.self, forKey: .subjectId)
        validityPeriod = try container.decodeIfPresent(Double.self, forKey: .validityPeriod)
        claims = try container.decode(Any.self, forKey: .claims)
        automaticIssuance = try container.decodeIfPresent(Bool.self, forKey: .automaticIssuance)
        createdAt = try container.decode(Date.self, forKey: .createdAt)
        updatedAt = try container.decodeIfPresent(Date.self, forKey: .updatedAt)
        role = try container.decode(Role.self, forKey: .role)
        protocolState = try container.decode(ProtocolState.self, forKey: .protocolState)
        jwtCredential = try container.decodeIfPresent(String.self, forKey: .jwtCredential)
        issuingDID = try container.decodeIfPresent(String.self, forKey: .issuingDID)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(recordId, forKey: .recordId)
        try container.encode(thid, forKey: .thid)
        try container.encodeIfPresent(subjectId, forKey: .subjectId)
        try container.encodeIfPresent(validityPeriod, forKey: .validityPeriod)
        try container.encode(try JSONSerialization.data(withJSONObject: claims), forKey: .claims)
        try container.encodeIfPresent(automaticIssuance, forKey: .automaticIssuance)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(updatedAt, forKey: .updatedAt)
        try container.encode(role, forKey: .role)
        try container.encode(protocolState, forKey: .protocolState)
        try container.encodeIfPresent(jwtCredential, forKey: .jwtCredential)
        try container.encodeIfPresent(issuingDID, forKey: .issuingDID)
    }
}
