//
// ConnectionsPage.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct ConnectionsPage: Codable {
    /// 
    public var contents: [Connection]?
    /// 
    public var kind: String
    /// 
    public var _self: String
    /// 
    public var pageOf: String
    /// 
    public var next: String?
    /// 
    public var previous: String?

    public init(contents: [Connection]? = nil, kind: String, _self: String, pageOf: String, next: String? = nil, previous: String? = nil) {
        self.contents = contents
        self.kind = kind
        self._self = _self
        self.pageOf = pageOf
        self.next = next
        self.previous = previous
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case contents
        case kind
        case _self = "self"
        case pageOf
        case next
        case previous
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        contents = try container.decodeIfPresent([Connection].self, forKey: .contents)
        kind = try container.decode(String.self, forKey: .kind)
        _self = try container.decode(String.self, forKey: ._self)
        pageOf = try container.decode(String.self, forKey: .pageOf)
        next = try container.decodeIfPresent(String.self, forKey: .next)
        previous = try container.decodeIfPresent(String.self, forKey: .previous)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(contents, forKey: .contents)
        try container.encode(kind, forKey: .kind)
        try container.encode(_self, forKey: ._self)
        try container.encode(pageOf, forKey: .pageOf)
        try container.encodeIfPresent(next, forKey: .next)
        try container.encodeIfPresent(previous, forKey: .previous)
    }
}
