//
// CredentialSchemaResponsePage.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct CredentialSchemaResponsePage: Codable {
    /// A sequence of CredentialSchemaResponse objects representing the list of credential schemas that the API response contains
    public var contents: [CredentialSchemaResponse]?
    /// A string field indicating the type of the API response. In this case, it will always be set to `CredentialSchemaPage`
    public var kind: String
    /// A string field containing the URL of the current API endpoint
    public var _self: String
    /// A string field indicating the type of resource that the contents field contains
    public var pageOf: String
    /// An optional string field containing the URL of the next page of results. If the API response does not contain any more pages, this field should be set to None.
    public var next: String?
    /// An optional string field containing the URL of the previous page of results. If the API response is the first page of results, this field should be set to None.
    public var previous: String?

    public init(contents: [CredentialSchemaResponse]? = nil, kind: String, _self: String, pageOf: String, next: String? = nil, previous: String? = nil) {
        self.contents = contents
        self.kind = kind
        self._self = _self
        self.pageOf = pageOf
        self.next = next
        self.previous = previous
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case contents
        case kind
        case _self = "self"
        case pageOf
        case next
        case previous
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        contents = try container.decodeIfPresent([CredentialSchemaResponse].self, forKey: .contents)
        kind = try container.decode(String.self, forKey: .kind)
        _self = try container.decode(String.self, forKey: ._self)
        pageOf = try container.decode(String.self, forKey: .pageOf)
        next = try container.decodeIfPresent(String.self, forKey: .next)
        previous = try container.decodeIfPresent(String.self, forKey: .previous)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(contents, forKey: .contents)
        try container.encode(kind, forKey: .kind)
        try container.encode(_self, forKey: ._self)
        try container.encode(pageOf, forKey: .pageOf)
        try container.encodeIfPresent(next, forKey: .next)
        try container.encodeIfPresent(previous, forKey: .previous)
    }
}
