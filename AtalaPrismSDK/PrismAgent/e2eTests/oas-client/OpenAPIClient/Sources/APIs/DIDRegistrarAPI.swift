//
// DIDRegistrarAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class DIDRegistrarAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum GetDidRegistrarDidsError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "GetDidRegistrarDidsError: Invalid request parameters: \(object)"
            case .code500Error(let object):
                return "GetDidRegistrarDidsError: Internal server error: \(object)"
            }
        }
    }

    /// List all DIDs stored in Prism Agent's wallet
    /// - GET /did-registrar/dids
    /// - List all DIDs stored in Prism Agent's wallet. Return a paginated items ordered by created timestamp. If the `limit` parameter is not set, it defaults to 100 items per page.
    /// - parameter offset: (query)  (optional)
    /// - parameter limit: (query)  (optional)
    /// - returns: AnyPublisher<ManagedDIDPage, Error> 
    open func getDidRegistrarDids(offset: Int? = nil, limit: Int? = nil) -> AnyPublisher<ManagedDIDPage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/did-registrar/dids"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let offset = offset { queryItems.append(URLQueryItem(name: "offset", value: "\(offset)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ManagedDIDPage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return GetDidRegistrarDidsError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return GetDidRegistrarDidsError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ManagedDIDPage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum GetDidRegistrarDidsDidrefError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Resource could not be found
        case code404Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "GetDidRegistrarDidsDidrefError: Invalid request parameters: \(object)"
            case .code404Error(let object):
                return "GetDidRegistrarDidsDidrefError: Resource could not be found: \(object)"
            case .code500Error(let object):
                return "GetDidRegistrarDidsDidrefError: Internal server error: \(object)"
            }
        }
    }

    /// Get DID stored in Prism Agent's wallet
    /// - GET /did-registrar/dids/{didRef}
    /// - Get DID stored in Prism Agent's wallet
    /// - parameter didRef: (path) Prism DID according to [the Prism DID method syntax](https://github.com/input-output-hk/prism-did-method-spec/blob/main/w3c-spec/PRISM-method.md#prism-did-method-syntax) 
    /// - returns: AnyPublisher<ManagedDID, Error> 
    open func getDidRegistrarDidsDidref(didRef: String) -> AnyPublisher<ManagedDID, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/did-registrar/dids/{didRef}"
                path = path.replacingOccurrences(of: "{didRef}", with: didRef)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ManagedDID, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return GetDidRegistrarDidsDidrefError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return GetDidRegistrarDidsDidrefError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return GetDidRegistrarDidsDidrefError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ManagedDID.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PostDidRegistrarDidsError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Unable to process the request
        case code422Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PostDidRegistrarDidsError: Invalid request parameters: \(object)"
            case .code422Error(let object):
                return "PostDidRegistrarDidsError: Unable to process the request: \(object)"
            case .code500Error(let object):
                return "PostDidRegistrarDidsError: Internal server error: \(object)"
            }
        }
    }

    /// Create unpublished DID and store it in Prism Agent's wallet
    /// - POST /did-registrar/dids
    /// - Create unpublished DID and store it inside Prism Agent's wallet. The private keys of the DID is managed by Prism Agent. The DID can later be published to the VDR using publications endpoint.
    /// - parameter createManagedDidRequest: (body)  
    /// - returns: AnyPublisher<CreateManagedDIDResponse, Error> 
    open func postDidRegistrarDids(createManagedDidRequest: CreateManagedDidRequest) -> AnyPublisher<CreateManagedDIDResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/did-registrar/dids"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(createManagedDidRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CreateManagedDIDResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 422 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsError.code422Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CreateManagedDIDResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PostDidRegistrarDidsDidrefDeactivationsError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Resource could not be found
        case code404Error(ErrorResponse)
        // Unable to process the request
        case code422Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PostDidRegistrarDidsDidrefDeactivationsError: Invalid request parameters: \(object)"
            case .code404Error(let object):
                return "PostDidRegistrarDidsDidrefDeactivationsError: Resource could not be found: \(object)"
            case .code422Error(let object):
                return "PostDidRegistrarDidsDidrefDeactivationsError: Unable to process the request: \(object)"
            case .code500Error(let object):
                return "PostDidRegistrarDidsDidrefDeactivationsError: Internal server error: \(object)"
            }
        }
    }

    /// Deactivate DID in Prism Agent's wallet and post deactivate operation to the VDR
    /// - POST /did-registrar/dids/{didRef}/deactivations
    /// - Deactivate DID in Prism Agent's wallet and post deactivate operation to the VDR.
    /// - parameter didRef: (path) Prism DID according to [the Prism DID method syntax](https://github.com/input-output-hk/prism-did-method-spec/blob/main/w3c-spec/PRISM-method.md#prism-did-method-syntax) 
    /// - returns: AnyPublisher<DIDOperationResponse, Error> 
    open func postDidRegistrarDidsDidrefDeactivations(didRef: String) -> AnyPublisher<DIDOperationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/did-registrar/dids/{didRef}/deactivations"
                path = path.replacingOccurrences(of: "{didRef}", with: didRef)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DIDOperationResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefDeactivationsError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefDeactivationsError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 422 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefDeactivationsError.code422Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefDeactivationsError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DIDOperationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PostDidRegistrarDidsDidrefPublicationsError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Resource could not be found
        case code404Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PostDidRegistrarDidsDidrefPublicationsError: Invalid request parameters: \(object)"
            case .code404Error(let object):
                return "PostDidRegistrarDidsDidrefPublicationsError: Resource could not be found: \(object)"
            case .code500Error(let object):
                return "PostDidRegistrarDidsDidrefPublicationsError: Internal server error: \(object)"
            }
        }
    }

    /// Publish the DID stored in Prism Agent's wallet to the VDR
    /// - POST /did-registrar/dids/{didRef}/publications
    /// - Publish the DID stored in Prism Agent's wallet to the VDR.
    /// - parameter didRef: (path) Prism DID according to [the Prism DID method syntax](https://github.com/input-output-hk/prism-did-method-spec/blob/main/w3c-spec/PRISM-method.md#prism-did-method-syntax) 
    /// - returns: AnyPublisher<DIDOperationResponse, Error> 
    open func postDidRegistrarDidsDidrefPublications(didRef: String) -> AnyPublisher<DIDOperationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/did-registrar/dids/{didRef}/publications"
                path = path.replacingOccurrences(of: "{didRef}", with: didRef)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DIDOperationResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefPublicationsError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefPublicationsError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefPublicationsError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DIDOperationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum PostDidRegistrarDidsDidrefUpdatesError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Resource could not be found
        case code404Error(ErrorResponse)
        // Cannot process due to conflict with current state of the resource
        case code409Error(ErrorResponse)
        // Unable to process the request
        case code422Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "PostDidRegistrarDidsDidrefUpdatesError: Invalid request parameters: \(object)"
            case .code404Error(let object):
                return "PostDidRegistrarDidsDidrefUpdatesError: Resource could not be found: \(object)"
            case .code409Error(let object):
                return "PostDidRegistrarDidsDidrefUpdatesError: Cannot process due to conflict with current state of the resource: \(object)"
            case .code422Error(let object):
                return "PostDidRegistrarDidsDidrefUpdatesError: Unable to process the request: \(object)"
            case .code500Error(let object):
                return "PostDidRegistrarDidsDidrefUpdatesError: Internal server error: \(object)"
            }
        }
    }

    /// Update DID in Prism Agent's wallet and post update operation to the VDR
    /// - POST /did-registrar/dids/{didRef}/updates
    /// - Update DID in Prism Agent's wallet and post update operation to the VDR. This endpoint updates the DID document from the last confirmed operation. Submitting multiple update operations without waiting for confirmation will result in some operations being rejected as only one operation is allowed to be appended to the last confirmed operation.
    /// - parameter didRef: (path) Prism DID according to [the Prism DID method syntax](https://github.com/input-output-hk/prism-did-method-spec/blob/main/w3c-spec/PRISM-method.md#prism-did-method-syntax) 
    /// - parameter updateManagedDIDRequest: (body)  
    /// - returns: AnyPublisher<DIDOperationResponse, Error> 
    open func postDidRegistrarDidsDidrefUpdates(didRef: String, updateManagedDIDRequest: UpdateManagedDIDRequest) -> AnyPublisher<DIDOperationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/did-registrar/dids/{didRef}/updates"
                path = path.replacingOccurrences(of: "{didRef}", with: didRef)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(updateManagedDIDRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DIDOperationResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefUpdatesError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefUpdatesError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 409 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefUpdatesError.code409Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 422 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefUpdatesError.code422Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return PostDidRegistrarDidsDidrefUpdatesError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DIDOperationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
