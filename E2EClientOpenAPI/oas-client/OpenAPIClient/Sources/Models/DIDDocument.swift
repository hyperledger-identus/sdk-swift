//
// DIDDocument.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/// A W3C compliant Prism DID document representation. 
public struct DIDDocument: Codable {
    /// The JSON-LD context for the DID resolution result.
    public var context: [String]?
    /// [DID subject](https://www.w3.org/TR/did-core/#did-subject). The value must match the DID that was given to the resolver.
    public var id: String
    /// [DID controller](https://www.w3.org/TR/did-core/#did-controller)
    public var controller: String?
    public var verificationMethod: [VerificationMethod]?
    public var authentication: [String]?
    public var assertionMethod: [String]?
    public var keyAgreement: [String]?
    public var capabilityInvocation: [String]?
    public var capabilityDelegation: [String]?
    public var service: [Service]?

    public init(context: [String]? = nil, id: String, controller: String? = nil, verificationMethod: [VerificationMethod]? = nil, authentication: [String]? = nil, assertionMethod: [String]? = nil, keyAgreement: [String]? = nil, capabilityInvocation: [String]? = nil, capabilityDelegation: [String]? = nil, service: [Service]? = nil) {
        self.context = context
        self.id = id
        self.controller = controller
        self.verificationMethod = verificationMethod
        self.authentication = authentication
        self.assertionMethod = assertionMethod
        self.keyAgreement = keyAgreement
        self.capabilityInvocation = capabilityInvocation
        self.capabilityDelegation = capabilityDelegation
        self.service = service
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case context = "@context"
        case id
        case controller
        case verificationMethod
        case authentication
        case assertionMethod
        case keyAgreement
        case capabilityInvocation
        case capabilityDelegation
        case service
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        context = try container.decodeIfPresent([String].self, forKey: .context)
        id = try container.decode(String.self, forKey: .id)
        controller = try container.decodeIfPresent(String.self, forKey: .controller)
        verificationMethod = try container.decodeIfPresent([VerificationMethod].self, forKey: .verificationMethod)
        authentication = try container.decodeIfPresent([String].self, forKey: .authentication)
        assertionMethod = try container.decodeIfPresent([String].self, forKey: .assertionMethod)
        keyAgreement = try container.decodeIfPresent([String].self, forKey: .keyAgreement)
        capabilityInvocation = try container.decodeIfPresent([String].self, forKey: .capabilityInvocation)
        capabilityDelegation = try container.decodeIfPresent([String].self, forKey: .capabilityDelegation)
        service = try container.decodeIfPresent([Service].self, forKey: .service)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(context, forKey: .context)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(controller, forKey: .controller)
        try container.encodeIfPresent(verificationMethod, forKey: .verificationMethod)
        try container.encodeIfPresent(authentication, forKey: .authentication)
        try container.encodeIfPresent(assertionMethod, forKey: .assertionMethod)
        try container.encodeIfPresent(keyAgreement, forKey: .keyAgreement)
        try container.encodeIfPresent(capabilityInvocation, forKey: .capabilityInvocation)
        try container.encodeIfPresent(capabilityDelegation, forKey: .capabilityDelegation)
        try container.encodeIfPresent(service, forKey: .service)
    }
}
