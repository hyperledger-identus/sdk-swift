//
// SchemaRegistryAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class SchemaRegistryAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum CreateSchemaError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Resource could not be found
        case code404Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "CreateSchemaError: Invalid request parameters: \(object)"
            case .code404Error(let object):
                return "CreateSchemaError: Resource could not be found: \(object)"
            case .code500Error(let object):
                return "CreateSchemaError: Internal server error: \(object)"
            }
        }
    }

    /// Publish new schema to the schema registry
    /// - POST /schema-registry/schemas
    /// - Create the new credential schema record with metadata and internal JSON Schema on behalf of Cloud Agent. The credential schema will be signed by the keys of Cloud Agent and issued by the DID that corresponds to it.
    /// - parameter credentialSchemaInput: (body) JSON object required for the credential schema creation 
    /// - returns: AnyPublisher<CredentialSchemaResponse, Error> 
    open func createSchema(credentialSchemaInput: CredentialSchemaInput) -> AnyPublisher<CredentialSchemaResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/schema-registry/schemas"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(credentialSchemaInput)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CredentialSchemaResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return CreateSchemaError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return CreateSchemaError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return CreateSchemaError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CredentialSchemaResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum GetSchemaByIdError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Resource could not be found
        case code404Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "GetSchemaByIdError: Invalid request parameters: \(object)"
            case .code404Error(let object):
                return "GetSchemaByIdError: Resource could not be found: \(object)"
            case .code500Error(let object):
                return "GetSchemaByIdError: Internal server error: \(object)"
            }
        }
    }

    /// Fetch the schema from the registry by `guid`
    /// - GET /schema-registry/schemas/{guid}
    /// - Fetch the credential schema by the unique identifier
    /// - parameter guid: (path) Globally unique identifier of the credential schema record 
    /// - returns: AnyPublisher<CredentialSchemaResponse, Error> 
    open func getSchemaById(guid: UUID) -> AnyPublisher<CredentialSchemaResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/schema-registry/schemas/{guid}"
                path = path.replacingOccurrences(of: "{guid}", with: guid.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CredentialSchemaResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return GetSchemaByIdError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return GetSchemaByIdError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return GetSchemaByIdError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CredentialSchemaResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum LookupSchemasByQueryError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "LookupSchemasByQueryError: Invalid request parameters: \(object)"
            case .code500Error(let object):
                return "LookupSchemasByQueryError: Internal server error: \(object)"
            }
        }
    }

    /// Lookup schemas by indexed fields
    /// - GET /schema-registry/schemas
    /// - Lookup schemas by `author`, `name`, `tags` parameters and control the pagination by `offset` and `limit` parameters 
    /// - parameter author: (query)  (optional)
    /// - parameter name: (query)  (optional)
    /// - parameter version: (query)  (optional)
    /// - parameter tags: (query)  (optional)
    /// - parameter offset: (query)  (optional)
    /// - parameter limit: (query)  (optional)
    /// - parameter order: (query)  (optional)
    /// - returns: AnyPublisher<CredentialSchemaResponsePage, Error> 
    open func lookupSchemasByQuery(author: String? = nil, name: String? = nil, version: String? = nil, tags: String? = nil, offset: Int? = nil, limit: Int? = nil, order: String? = nil) -> AnyPublisher<CredentialSchemaResponsePage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/schema-registry/schemas"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let author = author { queryItems.append(URLQueryItem(name: "author", value: author)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let version = version { queryItems.append(URLQueryItem(name: "version", value: version)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let offset = offset { queryItems.append(URLQueryItem(name: "offset", value: "\(offset)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let order = order { queryItems.append(URLQueryItem(name: "order", value: order)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CredentialSchemaResponsePage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return LookupSchemasByQueryError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return LookupSchemasByQueryError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CredentialSchemaResponsePage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum TestError: Error, CustomStringConvertible {
        // Invalid value
        case code400Error(String)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "TestError: Invalid value: \(object)"
            }
        }
    }

    /// Trace the request input from the point of view of the server
    /// - GET /schema-registry/test
    /// - Trace the request input from the point of view of the server
    /// - returns: AnyPublisher<String, Error> 
    open func test() -> AnyPublisher<String, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/schema-registry/test"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<String, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(String.self, from: transportError.data)
                            return TestError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(String.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum UpdateSchemaError: Error, CustomStringConvertible {
        // Invalid request parameters
        case code400Error(ErrorResponse)
        // Resource could not be found
        case code404Error(ErrorResponse)
        // Internal server error
        case code500Error(ErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "UpdateSchemaError: Invalid request parameters: \(object)"
            case .code404Error(let object):
                return "UpdateSchemaError: Resource could not be found: \(object)"
            case .code500Error(let object):
                return "UpdateSchemaError: Internal server error: \(object)"
            }
        }
    }

    /// Publish the new version of the credential schema to the schema registry
    /// - PUT /schema-registry/{author}/{id}
    /// - Publish the new version of the credential schema record with metadata and internal JSON Schema on behalf of Cloud Agent. The credential schema will be signed by the keys of Cloud Agent and issued by the DID that corresponds to it.
    /// - parameter author: (path) DID of the identity which authored the credential schema. A piece of Metadata. 
    /// - parameter id: (path) A locally unique identifier to address the schema. UUID is generated by the backend. 
    /// - parameter credentialSchemaInput: (body) JSON object required for the credential schema update 
    /// - returns: AnyPublisher<CredentialSchemaResponse, Error> 
    open func updateSchema(author: String, id: UUID, credentialSchemaInput: CredentialSchemaInput) -> AnyPublisher<CredentialSchemaResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/schema-registry/{author}/{id}"
                path = path.replacingOccurrences(of: "{author}", with: author)
                path = path.replacingOccurrences(of: "{id}", with: id.uuidString)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(credentialSchemaInput)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CredentialSchemaResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return UpdateSchemaError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return UpdateSchemaError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(ErrorResponse.self, from: transportError.data)
                            return UpdateSchemaError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CredentialSchemaResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
